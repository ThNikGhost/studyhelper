# Архитектурные решения

## Дата создания: 2026-02-03

---

## 1. Выбор фреймворков

### Frontend: React + TypeScript + Vite

**Решение:** Использовать React с TypeScript и сборщиком Vite.

**Обоснование:**
- Vite обеспечивает быструю сборку и HMR (Hot Module Replacement)
- React — самая популярная библиотека с огромным сообществом
- TypeScript даёт типобезопасность и улучшает DX
- Отличная поддержка PWA через vite-plugin-pwa
- shadcn/ui предоставляет качественные компоненты с возможностью кастомизации

**Альтернативы рассмотренные:**
- Next.js — избыточен для PWA без SSR
- Vue.js — меньше готовых решений для PWA
- Svelte — меньше сообщество, сложнее найти решения

### Backend: Python + FastAPI

**Решение:** Использовать FastAPI как основной фреймворк.

**Обоснование:**
- Асинхронный из коробки — важно для парсинга и уведомлений
- Автоматическая генерация OpenAPI документации
- Встроенная валидация через Pydantic
- Высокая производительность
- Простота написания и поддержки кода

**Альтернативы рассмотренные:**
- Django — избыточен, Django REST Framework тяжеловесен
- Flask — нет async из коробки, больше бойлерплейта

### База данных: PostgreSQL

**Решение:** PostgreSQL как основная СУБД.

**Обоснование:**
- Надёжность и производительность
- Поддержка JSON для гибких структур данных
- Хорошая интеграция с SQLAlchemy
- Бесплатная и open-source

---

## 2. Архитектурные решения

### Структура API

**Решение:** RESTful API с версионированием.

```
/api/v1/auth/*
/api/v1/schedule/*
/api/v1/subjects/*
/api/v1/works/*
...
```

**Обоснование:**
- Простота и понятность
- Версионирование позволяет безболезненно обновлять API
- Стандартные HTTP методы (GET, POST, PUT, DELETE)

### Аутентификация: JWT

**Решение:** JWT токены с access (15 мин) и refresh (7 дней).

**Обоснование:**
- Stateless — не требует хранения сессий на сервере
- Хорошо подходит для PWA
- Простая реализация с python-jose

### Парный режим

**Решение:** Оба пользователя имеют доступ ко всем данным, но:
- Общие данные (subjects, works, teachers) — редактируют оба
- Персональные данные (WorkStatus, Attendance) — только владелец

**Обоснование:**
- Минимизация дублирования данных
- Возможность видеть прогресс партнёра
- Чёткое разделение ответственности

### Парсинг расписания

**Решение:** Playwright для парсинга, Celery для фоновых задач.

**Обоснование:**
- Сайт ОмГУ использует JavaScript для рендеринга
- Playwright умеет работать с SPA
- Celery позволяет запускать парсинг по расписанию (cron)
- Хеширование расписания для определения изменений

---

## 3. Структура базы данных

### Ключевые таблицы

```
users              — пользователи (макс 2)
semesters          — семестры
subjects           — предметы (привязка к семестру)
schedule_entries   — записи расписания
schedule_snapshots — снапшоты для отслеживания изменений
works              — учебные работы
work_statuses      — статусы работ (per user)
work_status_history — история изменений статусов
teachers           — преподаватели
attendance         — посещаемость (per user)
departments        — подразделения универа
buildings          — корпуса
classmates         — одногруппники
files              — файлы
push_subscriptions — подписки на push
notification_settings — настройки уведомлений
```

### Связи
- `subjects` → `semesters` (many-to-one)
- `works` → `subjects` (many-to-one)
- `work_statuses` → `works`, `users` (many-to-one)
- `schedule_entries` → `subjects`, `teachers` (many-to-one, nullable)
- `attendance` → `users`, `schedule_entries` (many-to-one)
- `files` → `subjects`, `users` (many-to-one)

---

## 4. Принципы разработки

### Код
- Type hints обязательны (Python, TypeScript)
- Docstrings в формате Google (Python)
- Компоненты — функциональные (React)
- Атомарные коммиты с conventional commits

### Тестирование
- Unit-тесты для бизнес-логики
- Integration-тесты для API
- Минимальное покрытие: 80%

### Безопасность
- Никаких секретов в коде
- Валидация всех входных данных (Pydantic)
- HTTPS в продакшене
- Защита от CSRF, XSS

---

## 5. PWA требования

- Service Worker для offline-режима
- Web App Manifest
- Push-уведомления (Web Push API)
- Установка на домашний экран
- Кеширование статики и API-ответов

---

---

## 6. Windows-специфичные решения

### PostgreSQL: локальная установка вместо Docker

**Решение:** На Windows использовать локально установленный PostgreSQL вместо Docker.

**Обоснование:**
- asyncpg (асинхронный драйвер PostgreSQL для Python) имеет критические проблемы на Windows при подключении к PostgreSQL в Docker:
  - `ConnectionResetError` из-за `ProactorEventLoop` (дефолтный event loop на Windows)
  - Проблемы с кодировкой сообщений об ошибках (cp1251 vs UTF-8)
- Альтернативные драйверы (psycopg, psycopg_async, aiopg) либо не поддерживаются в SQLAlchemy 2.0 async, либо имеют те же проблемы с кодировкой
- Локальный PostgreSQL работает стабильно с asyncpg

**Альтернативы рассмотренные:**
- `WindowsSelectorEventLoopPolicy` — не помогло
- Драйвер `psycopg` вместо `asyncpg` — проблемы с кодировкой и аутентификацией
- Драйвер `aiopg` — не поддерживается в SQLAlchemy 2.0 async mode
- WSL2 — избыточно для данного проекта

### Vite: явное указание host

**Решение:** В `vite.config.ts` явно указывать `host: '127.0.0.1'`.

**Обоснование:**
- На Windows `localhost` может резолвиться в IPv6 (`::1`), а Vite по умолчанию слушает только IPv4
- Явное указание `127.0.0.1` гарантирует работу на всех Windows-машинах

---

## 7. Frontend решения

### Tailwind CSS v4

**Решение:** Использовать Tailwind CSS v4 с новым синтаксисом `@theme`.

**Обоснование:**
- Tailwind v4 использует новый подход к конфигурации через CSS `@theme` директиву
- Старый синтаксис с `@layer base` и CSS-переменными не работает
- `@apply` для кастомных классов типа `border-border` не поддерживается — нужно использовать прямые CSS-свойства

### Регистрация: двухэтапный процесс

**Решение:** После успешной регистрации автоматически выполнять логин.

**Обоснование:**
- Backend `/auth/register` возвращает `UserResponse`, а не токены
- Для получения JWT токенов необходимо вызвать `/auth/login`
- Улучшает UX — пользователю не нужно вводить данные повторно

---

## 8. Календарь и время

### react-day-picker v9 вместо нативного date input

**Решение:** Использовать react-day-picker v9 с Popover вместо нативного `<input type="date">`.

**Обоснование:**
- Нативный date input вызывает `onChange` при навигации по месяцам в некоторых браузерах
- Это приводит к нежелательному обновлению страницы при простом просмотре календаря
- react-day-picker даёт полный контроль над поведением — дата меняется только при клике на конкретный день

**Реализация:**
- `@radix-ui/react-popover` для выпадающего окна
- `react-day-picker` v9 для календаря
- `date-fns` для локализации (русский язык)

### Локальное время вместо UTC

**Решение:** Все функции работы с датами используют локальное время браузера.

**Обоснование:**
- `new Date().toISOString()` возвращает UTC, что вызывает проблемы около полуночи
- Например, в 0:45 по Омску (UTC+6) `toISOString()` вернёт предыдущий день (18:45 UTC)
- Функции `getToday()`, `addDays()`, `isToday()` переписаны на локальное время

---

## 9. Загрузка файлов

### Аватарки: локальное хранение

**Решение:** Хранить аватарки локально в папке `uploads/avatars/`.

**Обоснование:**
- Простая реализация без внешних сервисов
- FastAPI StaticFiles для отдачи файлов
- Уникальные имена через UUID
- Валидация типа и размера файла (max 5MB, только изображения)

**Реализация:**
- `POST /api/v1/uploads/avatar` — загрузка
- `DELETE /api/v1/uploads/avatar/{filename}` — удаление
- Защита от path traversal атак

### photo_url: str вместо HttpUrl

**Решение:** Использовать `str` вместо `HttpUrl` для поля `photo_url` в схемах Classmate.

**Обоснование:**
- При загрузке аватарок сохраняется относительный путь (`/uploads/avatars/...`)
- `HttpUrl` требует полный URL с протоколом, что не подходит для относительных путей
- `str` позволяет хранить как полные URL, так и относительные пути

---

---

## 10. Code Review решения (2026-02-06)

### httpOnly cookies и JWT revocation — отложены

**Решение:** Не включать переход с localStorage на httpOnly cookies и механизм отзыва JWT в текущий PR.

**Обоснование:**
- Это масштабная переделка всей auth-системы (backend endpoints + frontend store + 264 теста)
- Лучше делать отдельным PR с фокусированным ревью
- Текущая JWT-реализация достаточна для MVP с 2 пользователями

### Rate limiting: slowapi

**Решение:** Использовать slowapi для rate limiting на auth endpoints.

**Обоснование:**
- Простая интеграция с FastAPI
- 5/minute на login, 3/minute на register — достаточно для защиты от brute-force
- Не требует внешних зависимостей (Redis) для простых случаев

### Upload security: magic bytes вместо расширений

**Решение:** Валидировать загружаемые файлы по magic bytes (сигнатуре), а не по расширению.

**Обоснование:**
- Расширение файла легко подделать
- Magic bytes (JPEG: FF D8 FF, PNG: 89 50 4E 47, WEBP: RIFF...WEBP) надёжно идентифицируют формат
- Streaming чтение по чанкам 8KB защищает от DoS через огромные файлы

### Frontend: shared Modal с accessibility

**Решение:** Единый Modal компонент вместо локальных модалок на каждой странице.

**Обоснование:**
- DRY: код модалки повторялся на 5 страницах
- Accessibility: role="dialog", aria-modal, ESC handler, focus management — реализованы один раз
- Единообразный UX

### Frontend: sonner вместо alert()

**Решение:** Использовать библиотеку sonner для toast-уведомлений вместо browser alert().

**Обоснование:**
- alert() блокирует UI и выглядит устаревшим
- sonner даёт неблокирующие toast-уведомления с автоскрытием
- Единый паттерн для success/error уведомлений во всём приложении

---

## 11. Frontend тестирование (2026-02-07)

### Vitest + @testing-library/react + MSW

**Решение:** Vitest как тестовый фреймворк, @testing-library/react для рендеринга, MSW для мокирования API.

**Обоснование:**
- Vitest нативно интегрируется с Vite (общая конфигурация, алиасы, плагины)
- @testing-library/react поощряет тестирование поведения, а не деталей реализации
- MSW перехватывает запросы на сетевом уровне — не нужно мокать axios напрямую
- jsdom как environment для имитации браузерного API

**Альтернативы рассмотренные:**
- Jest — требует отдельную конфигурацию трансформаций, дублирует то, что Vite уже делает
- Playwright/Cypress — E2E тесты избыточны для unit/integration уровня на этом этапе

### pool: 'forks' для Vitest на Windows

**Решение:** Использовать `pool: 'forks'` вместо дефолтного `pool: 'threads'`.

**Обоснование:**
- MSW + jsdom на Windows удерживают сокеты после завершения тестов
- `pool: 'forks'` использует child processes, которые гарантированно убиваются при завершении
- Все 70 тестов проходят корректно

---

## 12. PWA решения (2026-02-07)

### generateSW вместо injectManifest

**Решение:** Использовать `generateSW` (Workbox) для генерации Service Worker.

**Обоснование:**
- Стандартные стратегии кеширования покрывают все текущие потребности
- Не нужен кастомный SW-код
- Автоматический precaching app shell (JS/CSS/HTML)

**Альтернативы рассмотренные:**
- `injectManifest` — избыточен, нет потребности в кастомной SW-логике

### registerType: 'prompt'

**Решение:** Пользователь решает когда применять обновление SW.

**Обоснование:**
- `autoUpdate` может прервать работу пользователя посреди заполнения формы
- `prompt` показывает баннер "Доступна новая версия" с кнопкой "Обновить"
- Пользователь контролирует момент обновления

### NetworkFirst для API, precache для shell

**Решение:**
- App Shell (JS/CSS/HTML) — precache (Cache First)
- API `/api/v1/*` — NetworkFirst с таймаутом 3с и fallback на кеш (24h, 100 записей)

**Обоснование:**
- App shell меняется редко → precache оптимален
- API данные должны быть свежими → NetworkFirst с коротким таймаутом
- 24h TTL и 100 записей — разумный баланс между объёмом кеша и полезностью
- `method: 'GET'` — кешируем только GET-запросы, мутации не кешируем

### offline.html fallback

**Решение:** Статическая страница `public/offline.html` для навигационных запросов без кеша.

**Обоснование:**
- Если пользователь офлайн и precache не содержит нужный маршрут — вместо ошибки показываем понятную страницу
- `navigateFallback: 'index.html'` покрывает SPA-роутинг, `offline.html` — крайний fallback

### pwa-mock.ts для тестов

**Решение:** Вынести мок `virtual:pwa-register/react` в отдельный файл `src/test/pwa-mock.ts`.

**Обоснование:**
- `vi.hoisted()` нельзя экспортировать из `setup.ts` — ошибка `SyntaxError: Cannot export hoisted variable`
- Отдельный модуль позволяет импортировать мок-стейт и в `setup.ts`, и в тестовых файлах
- Сброс моков в `afterEach` в setup.ts — централизованный cleanup

---

## 13. Clickable schedule решения (2026-02-08)

### key prop вместо useEffect для сброса состояния модала

**Решение:** Разделить `LessonDetailModal` на обёртку и `LessonDetailContent`, используя `key={entry.id}` для сброса состояния.

**Обоснование:**
- React 19 ESLint запрещает `setState` внутри `useEffect` (`react-hooks/set-state-in-effect`)
- React 19 ESLint запрещает доступ к ref.current во время рендера (`react-hooks/refs`)
- `key` prop вызывает полное пересоздание компонента при смене entry — чистый сброс всего состояния
- `useState(entry.notes ?? '')` в `LessonDetailContent` — инициализация без side effects

### tsconfig.app.json exclude для тестов

**Решение:** Добавить exclude `__tests__`, `*.test.ts`, `*.test.tsx`, `test/` в tsconfig.app.json.

**Обоснование:**
- `tsc -b` (используется в `npm run build`) включал тестовые файлы, которые зависят от Vitest глобалов (describe, it, vi)
- tsconfig.app.json не имел exclude — тестовые файлы компилировались без типов Vitest
- Раньше скрывалось кэшем `.tsbuildinfo`, но при любом `--clean` build ломался

---

## История изменений

| Дата | Решение | Причина |
|------|---------|---------|
| 2026-02-03 | Создан документ | Инициализация проекта |
| 2026-02-04 | PostgreSQL локально на Windows | asyncpg + Docker несовместимы на Windows |
| 2026-02-04 | Vite host: 127.0.0.1 | IPv6/IPv4 проблемы на Windows |
| 2026-02-04 | Tailwind v4 @theme синтаксис | Новая версия требует новый подход |
| 2026-02-04 | Автологин после регистрации | Backend не возвращает токены при регистрации |
| 2026-02-05 | react-day-picker вместо native date | Контроль над onChange при навигации |
| 2026-02-05 | Локальное время вместо UTC | Корректная работа около полуночи |
| 2026-02-05 | photo_url: str вместо HttpUrl | Поддержка относительных путей для аватарок |
| 2026-02-05 | Локальное хранение аватарок | Простота реализации без внешних сервисов |
| 2026-02-06 | httpOnly cookies отложены | Масштабная переделка, отдельный PR |
| 2026-02-06 | slowapi для rate limiting | Простая защита auth endpoints от brute-force |
| 2026-02-06 | Magic bytes для upload | Надёжнее расширений, защита от подделки |
| 2026-02-06 | Shared Modal + sonner toasts | DRY, accessibility, UX |
| 2026-02-07 | Vitest + testing-library + MSW | Нативная интеграция с Vite, тесты поведения |
| 2026-02-07 | pool: 'forks' в Vitest | MSW + jsdom подвисают на Windows с threads |
| 2026-02-07 | generateSW для PWA | Стандартные стратегии, не нужен кастомный SW |
| 2026-02-07 | registerType: prompt | Пользователь контролирует момент обновления |
| 2026-02-07 | NetworkFirst для API (3s timeout) | Свежие данные с fallback на кеш |
| 2026-02-07 | pwa-mock.ts для тестов | vi.hoisted() нельзя экспортировать из setup.ts |
| 2026-02-08 | key prop для сброса состояния модала | React 19 ESLint запрещает setState в useEffect |
| 2026-02-08 | tsconfig.app exclude тестов | tsc -b включал тесты без Vitest типов |
